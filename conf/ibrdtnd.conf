#####################################
# IBR-DTN daemon                    #
#####################################

#
# the local eid of the dtn node
# default is the hostname
#
#local_uri = dtn://node.dtn

#
# specifies an additional logfile
#
#logfile = /var/log/ibrdtn.log

#
# timezone offset in hours
#
#timezone = +1

#
# Limit the block size of all bundles
# The value accepts different multipliers.
# G = 1,000,000,000 bytes
# M = 1,000,000 bytes
# K = 1,000 bytes
#
#limit_blocksize = 1.3G

#
# Limit the offset of predated timestamps to a max value.
# Bundles with an invalid timestamp will be rejected.
#
#limit_predated_timestamp = 604800

#
# Limit the max. lifetime of a bundle-
# Bundles with a lifetime greater than this value will be rejected.
#
#limit_lifetime = 604800

# set the user for the daemon
#user = dtnd

# bind API to a named socket instead of an interface
#api_socket = /tmp/ibrdtn.sock

# define the interface for the API, choose any to bind on all interfaces
#api_interface = any

# define the port for the API to bind on
#api_port = 4550

#
# enable fragmentation support
# (default is disabled)
#
#fragmentation = yes

#####################################
# storage configuration             #
#####################################

#
# define a folder for temporary storage of bundles
# if this is not defined bundles will processed in memory
#
blob_path = blobs

#
# define a folder for persistent storage of bundles
# if this is not defined bundles will stored in memory only
#
storage_path = bundles

#
# defines the storage module to use
# default is "simple" using memory or disk (depending on storage_path)
# storage strategy. if compiled with sqlite support, you could change
# this to sqlite to use a sql database for bundles.
#
storage = default

#
# Limit the size of the storage.
# The value accepts different multipliers.
# G = 1,000,000,000 bytes
# M = 1,000,000 bytes
# K = 1,000 bytes
#
#limit_storage = 20M


#####################################
# statistic logging                 #
#####################################

#
# types: stdout | syslog | plain | csv | stat | udp
#
# statistic_type = stat
# statistic_interval = 2
# statistic_file = /tmp/ibrdtn.stats
# statistic_address = 127.0.0.1
# statistic_port = 1234


#####################################
# convergence layer configuration   #
#####################################

#
# discovery over UDP/IP
#
# You can specify an address to listen to for discovery announcements.
# Multicast addresses are supported. If no address is specified the default
# broadcast address is used.
#
#discovery_address = 224.0.0.1

# Specify the timeout. If no further discovery announcement is received
# for x seconds, the daemon assume that the node has went away.
#discovery_timeout = 5

# use short IPND beacons
#discovery_short = 0

# specify the discovery mechanism to use
# 0 = DTN2 compatible discovery
# 1 = IPND version 0
# 2 = IPND version 1 (default)
#discovery_version = 2

# To disable discovery announcements, set this option to zero.
# (default is 1)
#
#discovery_announce = 0

#
# a list (seperated by spaces) of names for convergence layer instances.
#
net_interfaces = lan0

#
# dynamic rebind to network interfaces
# If this feature is enabled, then a socket will be rebound on the
# network interface if the address has changed or the interface is
# temporarily down.
#
net_rebind = yes

#
# Try to connect to other nodes each x seconds.
# This option keeps connections up all the time.
#
#net_autoconnect = 60

#
# configuration for a convergence layer named lan0
#
net_lan0_type = tcp					# we want to use TCP as protocol
net_lan0_interface = eth1			# listen on interface eth0 
net_lan0_port = 4556				# with port 4556 (default)
net_lan0_discovery = yes			# enable discovery (default)

#
# configuration for a convergence layer named lan1
#
#net_lan1_type = udp				# we want to use UDP as protocol
#net_lan1_interface = eth0			# listen on interface eth0 
#net_lan1_port = 4556				# with port 4556 (default)
#net_lan1_discovery = no			# disable discovery

#
# TCP tuning options
#
# NODELAY option in TCP disables the nagle algorithm, if set to yes (default). 
#tcp_nodelay = yes
#
# The bundles are split into chunks while they are transmitted over TCP. This
# parameter defines the size of these chunks (4096 is the default).
#tcp_chunksize = 4096
#
# The timeout for idle TCP connection in seconds. 0 = disabled
#tcp_idle_timeout = 0


#####################################
# routing configuration             #
#####################################

#
# routing strategy
#
# values: default | epidemic | flooding | prophet
#
# In the "default" the daemon only delivers bundles to neighbors and static
# available nodes. The alternative module "epidemic" spread all bundles to
# all available neighbors. Flooding works like epidemic, but do not send the
# own summary vector to neighbors. Prophet forwards based on the probability
# to encounter other nodes (see draft-irtf-dtnrg-prophet-09).
#
routing = prophet

#
# forward bundles to other nodes (yes/no)
#
#routing_forwarding = yes

#
# static routing rules
# - a rule is a regex pattern
# - format is <target-scheme> <routing-node>
#
# route all bundles for "dtn://*.moon.dtn/*" to dtn://router.dtn
#route1 = ^dtn://[[:alpha:]].moon.dtn/[[:alpha:]] dtn://router.dtn	

#
# static connections
# for configure static connections it is important to begin with "static1_"
# and count up ("static2_", "static3_", ...)
#

### node-five.dtn ###
#static1_address = 10.0.0.5			# the node has the address 10.0.0.5
#static1_port = 4556				# accept bundles on port 4556
#static1_uri = dtn://node-five.dtn	# eid of the node is "dtn://node-five.dtn"
#static1_proto = tcp				# reachable over TCP
#static1_immediately = yes			# connect immediately to this node

### node-ten.dtn ###
#static2_address = 192.168.0.10		# the node has the address 10.0.0.10
#static2_port = 4556				# accept bundles on port 4556
#static2_uri = dtn://node-ten.dtn	# eid of the node is "dtn://node-ten.dtn"
#static2_proto = udp				# reachable over UDP
#static1_immediately = no			# connect on-demand to this node

### prophet configuration ###
#prophet_p_encounter_max = 0.7        #affects how strong the predictability is
                                      #increased on an encounter
#prophet_p_encounter_first = 0.5      #the predictability of a neighbor on the
                                      #first encounter
#prophet_p_first_threshold = 0.1      #lowest predictability when neighbors
                                      #predictabilities are forgotten
#prophet_beta = 0.9                   #Weight of the transitive property
#prophet_gamma = 0.999                #Determines how quickly predictabilities
                                      #age
#prophet_delta = 0.01                 #(1-delta) is the maximum predictability
#prophet_time_unit = 1                #time unit in seconds
#prophet_i_typ = 300                  #typical time interval between two node
                                      #encounters
#prophet_next_exchange_timeout = 60   #timeout how often handshakes should be
                                      #executed
#prophet_forwarding_strategy = GRTR   #The forwarding strategy used GRTR | GTMX
#prophet_gtmx_nf_max = 30             #Maximum times to forward in the GTMX
                                      #strategy

#####################################
# bundle security protocol          #
#####################################

#
# the level specifies the security constains
#
# 0 = no constrains (default)
# 1 = accept only BAB authenticated bundles
# 2 = accept only encrypted bundles
# 3 = accept only BAB authenticated and encrypted bundles
#security_level = 0

#
# bab default key
#
#security_bab_default_key = /etc/ibrdtn/bpsec/default-bab-key.mac

#
# key path
#
#security_path = /etc/ibrdtn/bpsec/keys

#
# TLS for TCP convergence layer
# Authentication and encryption (optional) support for every
# tcp connection between the daemons.
#
# certificate signed by the authority (public key)
#security_certificate = /etc/ibrdtn/tls/local.crt

# local TLS key
#security_key = /etc/ibrdtn/tls/local.key

# path to trusted certificates
#security_trusted_ca_path = /etc/ibrdtn/tls/

# set to 'yes' if tcp connections without TLS are not allowed
#security_tls_required = yes

# set to 'yes' to disable encryption in the TLS streams
#security_tls_disable_encryption = yes


#####################################
# time synchronization              #
#####################################

#
# set to yes if this node is connected to a high precision time reference
# like GPS, DCF77, NTP, etc.
#
#time_reference = yes

#
# set the quality of time decrease tick
#
#time_qot_tick = 0

#
# request time synchronization on discovery
#
#time_sync_on_discovery = yes

#
# announce time sync capabilities in discovery messages
#
#time_discovery_announcements = yes

#
# Parameters for the QoT aging process.
#
#time_sigma = 1.001
#time_sync_level = 0.15

#
# Adjust the clock of the host on each sync 
#
#time_set_clock = no


#####################################
# DHTNameService settings           #
#####################################

#
# Enable the DHT, if it was compiled
# Default is no
#
dht_enabled = yes

#
# Set the udp port, the DHT should working on
# Default is 9999
# If Port is 0, a random Port will be chosen for each run
#
dht_port = 9999

#
# Here you can choose a static DHT ID, which is very common
# Default is none -> a random ID per run will be generated
#dht_id = <randomstring>

#
# Enables DHT on IPv4 socket
# Default is yes
#
dht_enable_ipv4 = yes

#
# Enables DHT on IPv6 socket
# Default is yes
#
dht_enable_ipv6 = no

#
# Bind the DHT to a specific IPv4 Address
# Default is the any device
#
#dht_bind_ipv4 = 127.0.0.1

#
# Bind the DHT to a specific IPv6 Address
# Default is the any device
#
#dht_bind_ipv6 = ::1

#
# Specify the file, where the DHT can save all good nodes
# for faster restart on next session
# Default is no file, but it should be set
# 
#dht_nodes_file = <filepath>

#
# Enable DNS Bootstrapping for the DHT
#
#dht_bootstrapping = yes

#
# DNS Bootstrapping by giving domain names of wellknown nodes
#dht_bootstrapping_domains = [domain] [...]
#
# Example:
#dht_bootstrapping_domains = dtndht.ibr.cs.tu-bs.de
#
# Default is an empty string
#dht_bootstrapping_domains =

#
# IP Bootstrapping from wellknown IP (and port) addresses of nodes
#dht_bootstrapping_ips = [ip [port]]; [ip [port]]; ...
#
# Example:
#dht_bootstrapping_ips = 192.168.0.1; 192.168.0.2 8888;
#
# Default is an empty string
#dht_bootstrapping_ips =

#
# Blacklist support of the DHT can be switch on and off
#
# Default is yes
dht_blacklist = no

#
# Announcing myself on the DHT
#
# Default is yes
dht_self_announce = yes

#
# Minimum necessary rating of a DHT information
#
# The lowest rating is 0: the node information has been sent by only one DHT node
# The maximum rating is 10 (for single lookups) and means: 10 or more different DHT nodes sent the information
#
# If the rating of an incoming information is lower, it will be ignored
#
# Default is 1
dht_min_rating = 0

#
# Allow announcing neighbours
#
# Default is yes
#dht_allow_neighbour_announcement = yes

#
# Allow all neighbours announce them to be neighbour to me
# For privacy reasons, you could turn this off
#
# Default is yes
#dht_allow_neighbours_to_announce_me = yes

#
# Ignoring the neighbour information sent by a node, found on the DHT
#
# Default is no
#dht_ignore_neighbour_informations = no
